<article>

  <hr />

  <h2>1. .NET BCL에 추가된 async 메서드</h2>

  <h3>1-1. BCL + async 메서드란?</h3>

  <p>
    먼저 BCL(Base Class Library)를 한 줄로 정리하면:
  </p>

  <blockquote>
    .NET이 기본으로 제공하는 표준 라이브러리 묶음 (예: <code>System.IO</code>, <code>System.Net.Http</code>, <code>System.Data</code>, <code>System.Threading.Tasks</code> 등)
  </blockquote>

  <p>
    .NET 4.5 이후부터 이 BCL 곳곳에 <strong>비동기 메서드</strong>들이 대량으로 추가됐다. 특징은:
  </p>

  <ul>
    <li>이름 끝에 <code>Async</code>가 붙고</li>
    <li>반환 타입이 <code>Task</code> 또는 <code>Task&lt;T&gt;</code>이고</li>
    <li>내부에서 OS의 비동기 IO를 사용해서 <strong>스레드를 블록하지 않는다</strong></li>
  </ul>

  <h3>1-2. 대표적인 BCL async 메서드 예시</h3>

  <ul>
    <li><strong>파일/스트림 IO</strong>
      <ul>
        <li><code>Stream.ReadAsync</code>, <code>Stream.WriteAsync</code></li>
        <li><code>FileStream.ReadAsync</code>, <code>FileStream.WriteAsync</code></li>
      </ul>
    </li>
    <li><strong>HTTP/네트워크</strong>
      <ul>
        <li><code>HttpClient.GetAsync</code>, <code>PostAsync</code>, <code>SendAsync</code></li>
        <li><code>NetworkStream.ReadAsync</code>, <code>WriteAsync</code></li>
      </ul>
    </li>
    <li><strong>DB / Entity Framework</strong>
      <ul>
        <li><code>DbCommand.ExecuteReaderAsync</code>, <code>ExecuteNonQueryAsync</code></li>
        <li><code>DbContext.SaveChangesAsync</code></li>
      </ul>
    </li>
    <li><strong>기타</strong>
      <ul>
        <li><code>Task.Delay</code></li>
        <li><code>Socket.*Async</code> 계열 등</li>
      </ul>
    </li>
  </ul>

  <p>
    이 메서드들은 “<strong>오래 걸리는 IO 작업을 스레드를 점유하지 않고 처리해준다</strong>”가 핵심이다.
  </p>

  <h3>1-3. 동기 vs 비동기 파일 읽기 간단 비교</h3>

  <pre><code class="language-csharp">// 동기 방식
using var fs = new FileStream(path, FileMode.Open, FileAccess.Read);
byte[] buffer = new byte[1024];
int read = fs.Read(buffer, 0, buffer.Length);  // 여기서 스레드가 블록됨
</code></pre>

  <pre><code class="language-csharp">// 비동기 방식
using var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, useAsync: true);
byte[] buffer = new byte[1024];
int read = await fs.ReadAsync(buffer, 0, buffer.Length); // await, 스레드는 풀려 있음
</code></pre>

  <p>
    동기 <code>Read</code>는 작업이 끝날 때까지 스레드를 묶어 두고,  
    비동기 <code>ReadAsync</code>는 “이 IO 끝나면 알려줘”라고 OS에 맡겨놓고 스레드는 다른 일도 할 수 있다.
  </p>

  <hr />

  <h2>2. Task / Task&lt;TResult&gt; 타입 자세히 보기</h2>

  <h3>2-1. Task는 ‘작업의 상태’를 표현하는 객체</h3>

  <blockquote>
    <strong>Task = “미래에 끝날 작업 하나”를 표현하는 타입</strong>
  </blockquote>

  <p>Task는 내부적으로 상태(state)를 가진다. 예를 들면:</p>

  <ul>
    <li><code>Created</code> : 아직 시작 전</li>
    <li><code>Running</code> : 실행 중</li>
    <li><code>RanToCompletion</code> : 정상 완료</li>
    <li><code>Faulted</code> : 예외 발생 후 종료</li>
    <li><code>Canceled</code> : 취소됨</li>
  </ul>

  <pre><code class="language-csharp">Task t = Task.Run(() =>
{
    // 뭔가 작업
});

await t;

Console.WriteLine(t.Status); // RanToCompletion / Faulted / Canceled 등
</code></pre>

  <p>
    비동기 작업 안에서 예외가 나면 <code>Task</code>가 <code>Faulted</code> 상태가 되고,  
    그 Task를 <code>await</code>하는 시점에 예외가 다시 던져진다.
  </p>

  <pre><code class="language-csharp">Task t = Task.Run(() =>
{
    throw new InvalidOperationException("에러 발생");
});

try
{
    await t;  // 여기서 예외가 터짐
}
catch (Exception ex)
{
    Console.WriteLine(ex.Message);
}
</code></pre>

  <h3>2-2. Task&lt;TResult&gt; = 결과를 담은 Task</h3>

  <pre><code class="language-csharp">Task&lt;int&gt; t = Task.Run(() =>
{
    // 오래 걸리는 계산
    return 42;
});

int result = await t;   // t.Result를 await로 안전하게 꺼내는 셈
</code></pre>

  <p>
    <code>Task&lt;T&gt;</code> 안에는 나중에 <code>T</code> 타입의 결과가 들어온다고 생각하면 된다.  
    <code>await</code>는 사실상:
  </p>

  <ol>
    <li>Task가 끝날 때까지 기다리고</li>
    <li>끝나면 <code>.Result</code> 값을 꺼내서</li>
    <li>예외가 있으면 다시 throw 해 주고</li>
    <li>그 값을 좌변 변수에 넣어주는 역할</li>
  </ol>

  <h3>2-3. Task와 Thread의 차이 (자주 헷갈리는 포인트)</h3>

  <ul>
    <li><strong>Thread</strong>는 OS 레벨의 실제 실행 흐름(스레드 하나)</li>
    <li><strong>Task</strong>는 “해야 할 일 하나(작업 단위)”를 표현하는 논리적인 개념</li>
  </ul>

  <p>
    Task는 스레드풀 위에서 돌 수도 있고, IO 대기 중에는 스레드를 점유하지 않고 기다릴 수도 있다.  
    즉, “비동기 = 항상 새로운 스레드를 만든다”는 개념이 아니다.
  </p>

  <hr />

  <h2>3. async 메서드의 반환 타입 규칙</h2>

  <h3>3-1. 기본 패턴 3가지</h3>

  <p><code>async</code>를 메서드에 붙일 때, 반환 타입은 보통 이 셋 중 하나다.</p>

  <ol>
    <li><code>async Task</code>  
      → 비동기 작업인데 리턴값이 필요 없는 경우</li>
    <li><code>async Task&lt;T&gt;</code>  
      → 비동기 작업인데 결과 값을 돌려줘야 하는 경우</li>
    <li><code>async void</code>  
      → 이벤트 핸들러용 특수 케이스 (WinForms, WPF의 <code>Button_Click</code> 등)</li>
  </ol>

  <pre><code class="language-csharp">// 반환값 없음
async Task DoWorkAsync()
{
    await Task.Delay(1000);
}

// int 결과 반환
async Task&lt;int&gt; GetNumberAsync()
{
    await Task.Delay(1000);
    return 42;
}

// UI 이벤트 핸들러 (WinForms, WPF 등)
async void Button_Click(object sender, EventArgs e)
{
    await Task.Delay(1000);
    MessageBox.Show("완료");
}
</code></pre>

  <h3>3-2. async void가 위험한 이유 (이벤트 핸들러 제외)</h3>

  <pre><code class="language-csharp">async void DoSomething()
{
    await Task.Delay(1000);
    throw new Exception("에러");
}
</code></pre>

  <ul>
    <li><code>async void</code> 메서드에서 발생한 예외는 호출자가 <code>try/catch</code>로 잡기 어렵다.</li>
    <li>호출자 입장에서 이 메서드가 끝났는지, 실패했는지, 취소됐는지를 알 방법이 없다.</li>
  </ul>

  <p>
    그래서 규칙은 간단하다.
  </p>

  <ul>
    <li><strong>일반 메서드</strong>: 웬만하면 <code>async void</code> 쓰지 말고 <strong><code>async Task</code></strong>로 만들기</li>
    <li><strong>이벤트 핸들러</strong>: 프레임워크가 <code>void</code> 시그니처를 요구하니 어쩔 수 없이 <code>async void</code></li>
  </ul>

  <h3>3-3. async 메서드는 내부적으로 상태 머신으로 변환된다</h3>

  <pre><code class="language-csharp">async Task&lt;int&gt; GetNumberAsync()
{
    await Task.Delay(1000);
    return 10;
}
</code></pre>

  <p>
    컴파일러는 위 코드를 컴파일할 때, 내부적으로 “상태 머신(state machine)” 코드로 변환한다.
  </p>

  <ul>
    <li><code>await</code>를 만날 때마다 “어디까지 실행했는지” 상태를 저장해 두고</li>
    <li>비동기 작업이 끝나면 그 상태를 다시 불러와서 이어서 실행한다</li>
  </ul>

  <p>
    개발자 입장에서는 동기 코드처럼 작성하지만,  
    실제로는 콜백 지옥을 컴파일러가 자동으로 펼쳐서 관리해 주는 셈이다.
  </p>

  <hr />

  <h2>4. async 메서드가 아닌 경우의 비동기 처리</h2>

  <h3>4-1. async 없이 Task 직접 반환하기</h3>

  <p>
    비동기 메서드를 만들 때 꼭 <code>async</code>를 써야만 하는 건 아니다.  
    <strong><code>Task</code> 또는 <code>Task&lt;T&gt;</code>만 반환해 주면 호출자는 <code>await</code>로 사용할 수 있다.</strong>
  </p>

  <pre><code class="language-csharp">Task&lt;int&gt; GetNumberAsync()
{
    // async 키워드 없음
    return Task.Run(() =>
    {
        // 무거운 작업이라고 가정
        Task.Delay(1000).Wait();
        return 7;
    });
}
</code></pre>

  <pre><code class="language-csharp">// 호출하는 쪽
int n = await GetNumberAsync();
</code></pre>

  <p>
    호출자는 이 메서드가 <code>async</code>인지 아닌지 알 필요가 없다.  
    <code>Task&lt;int&gt;</code>만 있으면 그냥 <code>await</code> 하면 끝이다.
  </p>

  <p>
    다만, 직접 Task를 조립하다 보면 예외/취소 처리 등에서 실수하기 쉽기 때문에  
    <strong>웬만하면 <code>async</code> + <code>await</code> 조합으로 작성하는 편이 더 안전하다</strong>.
  </p>

  <h3>4-2. 옛날 비동기 패턴(APM/EAP) 한 줄만 짚고 가기</h3>

  <p>async/await 이전에는 이런 패턴을 썼다.</p>

  <ul>
    <li><strong>APM (Asynchronous Programming Model)</strong>
      <ul>
        <li><code>BeginXXX</code> / <code>EndXXX</code> 콤보</li>
        <li>예: <code>BeginRead</code>, <code>EndRead</code></li>
      </ul>
    </li>
    <li><strong>EAP (Event-based Asynchronous Pattern)</strong>
      <ul>
        <li><code>XXXAsync</code> 메서드 + <code>XXXCompleted</code> 이벤트</li>
        <li>예: <code>WebClient.DownloadStringAsync</code> + <code>DownloadStringCompleted</code></li>
      </ul>
    </li>
  </ul>

  <p>
    요즘은 이 패턴들을 <code>TaskCompletionSource</code> 등으로 감싸서  
    <code>Task</code> 기반(TAP, Task-based Asynchronous Pattern)으로 바꾸고,  
    <code>async/await</code>로 사용하는 경우가 많다.
  </p>

  <h3>4-3. 동기 메서드를 비동기처럼 감싸는 Task.Run</h3>

  <pre><code class="language-csharp">Task&lt;string&gt; ReadFileAsyncWrapper(string path)
{
    return Task.Run(() =>
    {
        // 원래 동기 메서드
        return File.ReadAllText(path);
    });
}
</code></pre>

  <p>
    이렇게 하면 동기 메서드를 백그라운드 스레드에서 실행하게 만들 수 있다.  
    호출자는 다음처럼 쓸 수 있다.
  </p>

  <pre><code class="language-csharp">string text = await ReadFileAsyncWrapper("test.txt");
</code></pre>

  <p>
    다만 이 방식은 결국 스레드를 하나 잡아먹는 구조라서,  
    파일/네트워크 같은 IO는 가능하면 <strong>BCL에서 제공하는 진짜 비동기 메서드를 우선 사용하는 게 좋다</strong>.
  </p>

  <hr />

  <h2>5. 비동기 호출의 병렬 처리 (여러 작업 동시에)</h2>

  <h3>5-1. 순차 await vs 동시에 실행</h3>

  <p>나쁜(?) 패턴부터 보자.</p>

  <pre><code class="language-csharp">string html1 = await http.GetStringAsync(url1);
string html2 = await http.GetStringAsync(url2);
string html3 = await http.GetStringAsync(url3);
</code></pre>

  <ul>
    <li>url1 요청 → 완료</li>
    <li>그다음 url2 요청 → 완료</li>
    <li>그다음 url3 요청 → 완료</li>
  </ul>

  <p>
    각 요청이 1초씩 걸린다면 총 3초가 걸린다. IO는 대부분 “기다림”인데, 그 기다림을 순서대로 처리하는 셈이다.
  </p>

  <h3>5-2. 동시에 보내고 한 번에 기다리기 – Task.WhenAll</h3>

  <pre><code class="language-csharp">Task&lt;string&gt; t1 = http.GetStringAsync(url1);
Task&lt;string&gt; t2 = http.GetStringAsync(url2);
Task&lt;string&gt; t3 = http.GetStringAsync(url3);

// 세 요청을 동시에 출발시킨 뒤, 전부 끝날 때까지 기다리기
string[] results = await Task.WhenAll(t1, t2, t3);

string html1 = results[0];
string html2 = results[1];
string html3 = results[2];
</code></pre>

  <p>
    이 패턴에서는:
  </p>

  <ol>
    <li><code>GetStringAsync</code> 세 번을 빠르게 호출해서 <code>Task&lt;string&gt;</code> 세 개를 받는다.</li>
    <li>각 HTTP 요청이 동시에 진행된다.</li>
    <li><code>Task.WhenAll</code>은 “모든 Task가 끝날 때 완료되는 Task”를 하나 만들어 준다.</li>
    <li><code>await Task.WhenAll(...)</code> 하면, 세 요청이 모두 끝난 뒤에 결과 배열이 한 번에 들어온다.</li>
  </ol>

  <p>
    각 요청이 1초씩 걸려도, 전체적인 시간은 거의 1초 수준으로 줄어든다.
  </p>

  <h3>5-3. CPU 병렬 처리 간단 느낌</h3>

  <pre><code class="language-csharp">var tasks = new List&lt;Task&lt;int&gt;&gt;();

for (int i = 0; i &lt; 4; i++)
{
    int capture = i;
    tasks.Add(Task.Run(() => VeryHeavyCalc(capture)));
}

int[] results = await Task.WhenAll(tasks);
</code></pre>

  <p>
    <code>VeryHeavyCalc</code> 같은 CPU 중심 계산을 여러 조각으로 나누고,  
    <code>Task.Run</code>으로 여러 스레드에서 동시에 돌리는 예시다.
  </p>

  <p>
    실제로는 스레드풀이 여러 코어에 작업을 배분해서 병렬로 계산할 수 있고,  
    더 깊게 들어가면 <code>Parallel.For</code>, <code>Parallel.ForEach</code>, PLINQ(<code>AsParallel()</code>) 같은 것들도 배울 수 있다.
  </p>

  <p>
    입문 단계에서는 일단:
  </p>

  <blockquote>
    “여러 비동기 IO 작업을 함께 돌리고 싶으면  
    <strong>Task 여러 개 만들고 → <code>Task.WhenAll</code>로 한 번에 기다린다</strong>”
  </blockquote>

  <p>
    이 패턴만 확실하게 익혀둬도 비동기로 할 수 있는 일이 확 넓어진다.
  </p>

  <hr />

  <h2>정리</h2>

  <ul>
    <li><strong>BCL async 메서드</strong>  
      → .NET 기본 라이브러리에 붙어 있는 <code>XXXAsync</code> 메서드들.  
      IO 작업을 스레드 블록 없이 처리할 수 있게 해 준다.</li>

<pre><code>&lt;li&gt;&lt;strong&gt;Task / Task&amp;lt;T&amp;gt;&lt;/strong&gt;  
  → “미래에 끝날 작업”을 나타내는 타입.  
  &lt;code&gt;await&lt;/code&gt;로 자연스럽게 기다리면서 결과를 받을 수 있다.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;async 메서드 반환 타입&lt;/strong&gt;  
  → 일반 메서드는 &lt;code&gt;async Task&lt;/code&gt;, &lt;code&gt;async Task&amp;lt;T&amp;gt;&lt;/code&gt;  
  → 이벤트 핸들러만 예외적으로 &lt;code&gt;async void&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;async 아닌 비동기&lt;/strong&gt;  
  → Task를 직접 만들어 반환하거나, 레거시 콜백 기반 비동기를 Task로 감싸서 사용.  
  동기 CPU 작업은 &lt;code&gt;Task.Run&lt;/code&gt;으로 백그라운드에서 돌릴 수도 있다.&lt;/li&gt;

&lt;li&gt;&lt;strong&gt;비동기 병렬 처리&lt;/strong&gt;  
  → 순차 &lt;code&gt;await&lt;/code&gt; 대신, Task 여러 개를 동시에 시작하고  
  &lt;code&gt;Task.WhenAll&lt;/code&gt;로 한 번에 기다리면 IO 작업을 동시에 진행할 수 있다.&lt;/li&gt;</code></pre>  </ul>

</article>