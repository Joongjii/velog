<article>

  <ul>
    <li>선언 패턴 / <code>var</code> 패턴 / discard(<code>_</code>) 패턴</li>
    <li>위치(포지셔널) 패턴 – 튜플 / <code>Deconstruct</code> / record</li>
    <li>논리 패턴 – <code>and</code>, <code>or</code>, <code>not</code></li>
    <li>리스트 패턴(List Pattern) 응용</li>
    <li>재귀(Recursive) 패턴 – 패턴들을 섞어서 쓰기</li>
    <li><code>when</code> 가드와 패턴의 조합</li>
    <li><code>foreach</code> + 튜플/패턴 활용</li>
  </ul>

  <hr />

  <h2>1. 선언 패턴, <code>var</code> 패턴, discard(<code>_</code>) 패턴</h2>

  <h3>1-1. 선언 패턴 (Declaration Pattern)</h3>

  <p>
    패턴 매칭의 가장 기본 형태는 “타입 검사 + 캐스팅”을 한 줄로 합친 <strong>선언 패턴</strong>이다.
  </p>

  <pre><code class="language-csharp">if (obj is string s)
{
    // s는 이미 string으로 캐스팅된 상태
    Console.WriteLine(s.ToUpper());
}</code></pre>

  <ul>
    <li><code>obj is string s</code>의 의미
      <ul>
        <li><code>obj</code>가 <code>string</code> 타입이면 <code>true</code></li>
        <li>동시에 <code>s</code>라는 이름의 지역 변수에 캐스팅된 결과를 넣어줌</li>
      </ul>
    </li>
  </ul>

  <p>
    예전에는
  </p>

  <pre><code class="language-csharp">if (obj is string)
{
    string s = (string)obj;
    ...
}</code></pre>

  <p>이렇게 타입 체크와 캐스팅을 따로 했지만, 선언 패턴 덕분에 한 줄로 줄일 수 있다.</p>

  <h3>1-2. <code>var</code> 패턴</h3>

  <p><code>var</code> 패턴은 “어떤 값이든 받되 이름만 붙이고 싶다”는 느낌으로 사용할 수 있다.</p>

  <pre><code class="language-csharp">if (obj is var x)
{
    // 항상 true, obj를 x라는 이름으로 받는 패턴
    Console.WriteLine(x);
}</code></pre>

  <p>
    이렇게만 보면 굳이 쓸 이유가 별로 없는데,  
    <strong>다른 패턴과 섞을 때</strong> “중간 값에 이름 붙이기” 용도로 쓸 수 있다.
  </p>

  <pre><code class="language-csharp">if (n is &gt; 0 and &lt; 100 and var inRange)
{
    Console.WriteLine($"범위 안 숫자: {inRange}");
}</code></pre>

  <ul>
    <li><code>n is &gt; 0 and &lt; 100</code>으로 0 &lt; n &lt; 100 범위를 체크</li>
    <li><code>and var inRange</code>로 그 값을 <code>inRange</code>라는 이름으로 꺼내 사용</li>
  </ul>

  <p>
    즉, <strong>조건 검사 + 별칭(alias) 부여</strong> 용도로 쓰는 패턴이다.
  </p>

  <h3>1-3. discard(<code>_</code>) 패턴</h3>

  <p>
    <code>_</code>는 “이 값은 굳이 쓰지 않을 거라서 버리겠다”는 의미의 패턴이다.
  </p>

  <pre><code class="language-csharp">(int x, int y, int z) point = (1, 2, 3);

if (point is (_, _, 3))
{
    Console.WriteLine("세 번째 값이 3이다");
}</code></pre>

  <ul>
    <li><code>(_, _, 3)</code> → 첫 번째, 두 번째 값은 신경 안 쓰고, 세 번째가 3인지 여부만 확인</li>
  </ul>

  <p>가장 익숙한 예는 <code>switch</code>의 <code>default</code> 역할이다.</p>

  <pre><code class="language-csharp">return code switch
{
    200 =&gt; "OK",
    400 =&gt; "Bad Request",
    _   =&gt; "Unknown"
};</code></pre>

  <p>
    <code>_</code>는 “나머지 모든 경우”를 의미하는 패턴이며,  
    값을 버리는 패턴(discard)이라고 이해하면 된다.
  </p>

  <hr />

  <h2>2. 위치(포지셔널) 패턴 – 튜플 / Deconstruct / record</h2>

  <p>
    위치(포지셔널) 패턴은 <strong>튜플</strong>이나 <strong>Deconstruct</strong>를 제공하는 타입을  
    “좌표”처럼 다룰 때 사용하는 패턴이다.
  </p>

  <h3>2-1. 튜플과 위치 패턴</h3>

  <pre><code class="language-csharp">(int x, int y) p = (10, 0);

string Describe((int x, int y) point) =&gt; point switch
{
    (0, 0)      =&gt; "원점",
    (_, 0)      =&gt; "X축 위",
    (0, _)      =&gt; "Y축 위",
    var (a, b)  =&gt; $"일반 점 ({a}, {b})"
};</code></pre>

  <ul>
    <li><code>(0, 0)</code> : x == 0, y == 0 일 때</li>
    <li><code>(_, 0)</code> : y == 0이고 x는 어떤 값이든</li>
    <li><code>(0, _)</code> : x == 0이고 y는 어떤 값이든</li>
    <li><code>var (a, b)</code> : 나머지 모든 경우 → 튜플 요소를 <code>a</code>, <code>b</code>로 꺼냄</li>
  </ul>

  <h3>2-2. <code>Deconstruct</code>를 가진 클래스/struct에도 사용 가능</h3>

  <p>
    튜플뿐 아니라, <code>Deconstruct</code> 메서드를 가진 타입도 위치 패턴으로 매칭할 수 있다.
  </p>

  <pre><code class="language-csharp">class Range
{
    public int Start { get; }
    public int End   { get; }

    public Range(int start, int end) =&gt; (Start, End) = (start, end);

    public void Deconstruct(out int start, out int end)
        =&gt; (start, end) = (Start, End);
}

string Describe(Range r) =&gt; r switch
{
    (0, 0)    =&gt; "빈 구간",
    (0, &gt; 0)  =&gt; "0 이상 양수 구간",
    var (s, e) =&gt; $"[{s} ~ {e}] 구간"
};</code></pre>

  <p>
    여기서 <code>(0, &gt; 0)</code> 같은 부분은  
    “위치 패턴 + 관계 패턴(<code>&gt; 0</code>)”이 섞인 형태다.
  </p>

  <hr />

  <h2>3. 논리 패턴: <code>and</code>, <code>or</code>, <code>not</code></h2>

  <p>
    논리 패턴은 기존의 <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>와 비슷한 역할을 하지만,  
    패턴 문법 안에서 자연스럽게 섞어서 쓸 수 있는 버전이다.
  </p>

  <pre><code class="language-csharp">if (n is &gt;= 0 and &lt;= 100)
{
    // 0~100 사이
}

if (n is &lt; 0 or &gt; 100)
{
    // 범위 밖
}

if (obj is not null)
{
    // null 아님
}</code></pre>

  <p>
    예를 들어 ERP 느낌으로 상태와 금액을 같이 볼 수도 있다.
  </p>

  <pre><code class="language-csharp">if (order is { Status: "CLOSE" or "CANCEL", Amount: &gt; 0 })
{
    Console.WriteLine("종료/취소 상태지만 금액은 0보다 큼");
}</code></pre>

  <ul>
    <li><code>Status: "CLOSE" or "CANCEL"</code> → 두 상태 중 하나면 매칭</li>
    <li><code>Amount: &gt; 0</code> → 금액이 0보다 큰 경우만</li>
  </ul>

  <p>이렇게 패턴만으로도 꽤 복잡한 조건을 표현할 수 있다.</p>

  <hr />

  <h2>4. 리스트 패턴(List Pattern) – 배열/리스트의 “모양”으로 매칭</h2>

  <p>
    C# 11부터 추가된 리스트 패턴은  
    <strong>배열/리스트의 형태</strong>로 매칭하는 기능이다.
  </p>

  <pre><code class="language-csharp">int[] arr = { 1, 2, 3, 4 };

string Describe(int[] xs) =&gt; xs switch
{
    []                =&gt; "빈 배열",
    [0]               =&gt; "0 하나만",
    [1, 2, 3]         =&gt; "1,2,3 딱 세 개",
    [1, ..]           =&gt; "1로 시작",
    [.., 4]           =&gt; "4로 끝",
    [_, _, _, _]      =&gt; "길이 4",
    [1, .. var rest]  =&gt; $"1로 시작 + 나머지 {rest.Length}개",
    _                 =&gt; "그 외"
};</code></pre>

  <ul>
    <li><code>[]</code> → 빈 배열</li>
    <li><code>[0]</code> → 요소가 하나이고 그 값이 0</li>
    <li><code>[1, 2, 3]</code> → 정확히 1,2,3 세 개일 때</li>
    <li><code>[1, ..]</code> → 첫 번째가 1이고 뒤에는 뭐든</li>
    <li><code>[.., 4]</code> → 마지막이 4</li>
    <li><code>[1, .. var rest]</code> → 1로 시작하고, 나머지를 <code>rest</code>로 받아서 사용</li>
  </ul>

  <p>ERP 예를 살짝 섞어 보면:</p>

  <pre><code class="language-csharp">// 특정 일자의 입출고 기록이 [입고, 출고, 출고] 순인지 체크
string CheckIoPattern(string[] iogbns) =&gt; iogbns switch
{
    ["I", "O", "O"] =&gt; "입고 후 2번 출고 패턴",
    ["I", .., "O"]  =&gt; "입고로 시작해서 출고로 끝나는 패턴",
    ["O", ..]       =&gt; "출고로 시작하는 특이 패턴",
    _               =&gt; "일반 패턴"
};</code></pre>

  <p>
    리스트 패턴을 한 번 익혀두면 시간 순서, 상태 변경 패턴 같은 것도  
    꽤 직관적으로 표현할 수 있다.
  </p>

  <hr />

  <h2>5. 재귀(Recursive) 패턴 – 패턴끼리 섞어서 쓰기</h2>

  <p>
    C# 패턴의 재미는 <strong>여러 패턴들을 섞어서</strong> 쓸 수 있다는 점이다.<br />
    속성 패턴, 확장 속성 패턴, 관계 패턴, 논리 패턴 등을 한 줄에 모아서<br />
    “조건 스펙”을 딱 표처럼 표현할 수 있다.
  </p>

  <pre><code class="language-csharp">class Order
{
    public string Status { get; set; }
    public decimal Amount { get; set; }
    public Customer Customer { get; set; }
}

class Customer
{
    public string Grade { get; set; }  // A, B, C 등급
}

string Describe(Order o) =&gt; o switch
{
    { Status: "CLOSE", Customer.Grade: "A", Amount: &gt; 1_000_000m }
        =&gt; "고액 프리미엄 종료 주문",

    { Status: "OPEN", Customer.Grade: "A" or "B" }
        =&gt; "우수 고객 진행 중 주문",

    { Status: "OPEN", Amount: &lt;= 0 }
        =&gt; "금액 없는 진행 주문",

    null
        =&gt; "null 주문",

    _
        =&gt; "일반 주문"
};</code></pre>

  <p>
    예를 들어 첫 번째 패턴:
  </p>

  <pre><code class="language-csharp">{ Status: "CLOSE", Customer.Grade: "A", Amount: &gt; 1_000_000m }</code></pre>

  <ul>
    <li><strong>속성 패턴</strong>: <code>Status</code>, <code>Amount</code></li>
    <li><strong>확장 속성 패턴</strong>: <code>Customer.Grade</code></li>
    <li><strong>관계 패턴</strong>: <code>Amount: &gt; 1_000_000m</code></li>
    <li>이 모든 걸 한 줄로 조합한 형태</li>
  </ul>

  <p>
    기존에 if/else로 길게 늘어졌던 조건문을  
    <code>switch</code> + 패턴 조합으로 정리하면  
    “조건 정의서”를 코드로 옮겨 놓은 것처럼 깔끔하게 보이는 효과가 있다.
  </p>

  <hr />

  <h2>6. 패턴 + <code>when</code> 가드</h2>

  <p>
    <code>when</code> 가드는 패턴 뒤에 “추가 필터”를 붙이고 싶을 때 사용한다.
  </p>

  <pre><code class="language-csharp">string Describe(int n) =&gt; n switch
{
    var x when x &lt; 0      =&gt; "음수",
    var x when x == 0     =&gt; "0",
    var x when x % 2 == 0 =&gt; "양수 짝수",
    _                     =&gt; "양수 홀수"
};</code></pre>

  <p>
    패턴으로 대략적인 범위를 잡고,  
    세부 조건은 <code>when</code>으로 필터링할 수도 있다.
  </p>

  <pre><code class="language-csharp">string Describe(Order o) =&gt; o switch
{
    { Status: "CLOSE" } when o.Amount == 0
        =&gt; "금액 0인 종료 주문",

    { Status: "CLOSE" }
        =&gt; "일반 종료 주문",

    _
        =&gt; "기타"
};</code></pre>

  <p>
    이런 식으로 “같은 패턴” 안에서 금액이 0인 경우와 아닌 경우를  
    <code>when</code> 가드로 나눠서 표현할 수 있다.
  </p>

  <hr />

  <h2>7. <code>foreach</code>와 튜플/패턴</h2>

  <p>
    <code>foreach</code>에서도 튜플 분해와 패턴을 같이 사용할 수 있다.
  </p>

  <h3>7-1. 튜플 분해</h3>

  <pre><code class="language-csharp">var users = new List&lt;(string Name, int Age)&gt;
{
    ("A", 10),
    ("B", 20),
    ("C", 30)
};

foreach (var (name, age) in users)
{
    Console.WriteLine($"{name} / {age}");
}</code></pre>

  <p>
    각 튜플 요소를 <code>name</code>, <code>age</code>로 바로 꺼내 쓸 수 있어  
    <code>user.Name</code>, <code>user.Age</code>보다 더 가볍게 데이터를 다룰 수 있다.
  </p>

  <h3>7-2. 튜플 + 패턴 매칭</h3>

  <pre><code class="language-csharp">foreach (var (name, age) in users)
{
    var grade = age switch
    {
        &lt; 13 =&gt; "어린이",
        &lt; 20 =&gt; "청소년",
        _    =&gt; "성인"
    };

    Console.WriteLine($"{name}는 {grade}");
}</code></pre>

  <p>
    튜플로 받은 데이터를 바로 <code>switch</code> 식 + 패턴으로 분류해서  
    코드를 간단하고 읽기 좋게 구성할 수 있다.
  </p>

  <hr />

  <h2>8. 전체 정리</h2>

  <p>C# 패턴 매칭을 머릿속에 이렇게 정리해 두면 편하다.</p>

  <h3>8-1. 어디서 쓰는가?</h3>

  <ul>
    <li><code>if (x is 패턴)</code></li>
    <li><code>switch (x) { case 패턴: ... }</code></li>
    <li><code>x switch { 패턴 =&gt; 결과, ... }</code> (switch 식)</li>
  </ul>

  <h3>8-2. 어떤 패턴들이 있는가?</h3>

  <ul>
    <li>선언 패턴: <code>is string s</code></li>
    <li><code>var</code> 패턴: <code>is var x</code></li>
    <li>discard 패턴: <code>_</code></li>
    <li>상수 패턴: <code>is 0</code>, <code>case "CLOSE":</code></li>
    <li>관계 패턴: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
    <li>논리 패턴: <code>and</code>, <code>or</code>, <code>not</code></li>
    <li>속성 패턴: <code>{ Prop: ..., Other: ... }</code></li>
    <li>확장 속성 패턴: <code>{ A.B: ..., A.C: ... }</code></li>
    <li>위치(포지셔널) 패턴: <code>(x, y)</code>, <code>Deconstruct</code></li>
    <li>리스트 패턴: <code>[]</code>, <code>[1, ..]</code>, <code>[.., 4]</code>, <code>[1, .. var rest]</code></li>
    <li><code>when</code> 가드: 패턴 뒤에 추가 조건</li>
  </ul>

</article>