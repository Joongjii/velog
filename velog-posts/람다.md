<article>


  <h2>1. 람다 메서드를 위한 전용 델리게이트 관점</h2>

  <h3>1-1. 람다는 결국 “메서드 조각”이다</h3>

  <p>
    람다는 한 줄로 말하면 이렇게 볼 수 있다.
  </p>

  <blockquote>
    람다식 = 어딘가에 넘겨줄 “작은 메서드 조각”을 코드 안에서 바로 적는 문법
  </blockquote>

  <p>
    그리고 이 “작은 메서드”를 담는 그릇이 바로 <strong>델리게이트 타입(delegate)</strong>이다.
  </p>

  <pre><code class="language-csharp">// 전용 델리게이트 타입 선언
delegate bool NumberTest(int n);

class Program
{
    static void Main()
    {
        NumberTest isEven = n =&gt; n % 2 == 0;   // 람다를 델리게이트에 담음
        NumberTest isOdd  = n =&gt; n % 2 != 0;

        Console.WriteLine(isEven(10)); // true
        Console.WriteLine(isOdd(10));  // false
    }
}</code></pre>

  <ul>
    <li><code>delegate bool NumberTest(int n);</code>  
      → “<strong>int 하나 받아서 bool을 반환하는 함수</strong>를 담는 전용 타입”</li>
    <li><code>n =&gt; n % 2 == 0</code>  
      → 이 부분이 바로 “<strong>익명 메서드 본문</strong>” 역할을 하는 람다식</li>
    <li><code>NumberTest isEven = ...</code>  
      → “이 델리게이트 변수는 이 람다 메서드를 가리킨다”는 뜻</li>
  </ul>

  <p>
    정리하면, 람다 자체는 <strong>익명 메서드</strong>이고,<br />
    그걸 담는 타입이 <strong>델리게이트</strong>라고 보면 된다.
  </p>

  <hr />

  <h3>1-2. 전용 델리게이트를 만들어 두면 좋은 이유</h3>

  <p>
    어떤 공통 함수를 만들고, “조건”만 바꿔가며 쓰고 싶을 때 전용 델리게이트가 유용하다.
  </p>

  <pre><code class="language-csharp">delegate bool NumberTest(int n);

static int Count(int[] numbers, NumberTest test)
{
    int count = 0;
    foreach (int n in numbers)
    {
        if (test(n))
            count++;
    }
    return count;
}</code></pre>

  <p>사용 예:</p>

  <pre><code class="language-csharp">int[] arr = { 1, 2, 3, 4, 5, 6 };

// 1) 일반 메서드 전달
static bool IsEven(int n) =&gt; n % 2 == 0;

int evenCount1 = Count(arr, IsEven);

// 2) 람다식으로 바로 조건 전달
int evenCount2 = Count(arr, n =&gt; n % 2 == 0);
int overThree  = Count(arr, n =&gt; n &gt; 3);</code></pre>

  <ul>
    <li><code>Count</code>는 “배열을 돌면서 조건에 맞는 것만 세는 공통 함수”</li>
    <li>어떤 조건으로 셀지는 <code>NumberTest</code> 델리게이트에 람다를 넣어 바꿔준다</li>
    <li>조건을 바꿔 끼우는 플러그인처럼 람다를 사용하는 느낌</li>
  </ul>

  <p>
    이 패턴이 확장된 게 <code>Predicate&lt;T&gt;</code>, <code>Comparison&lt;T&gt;</code> 같은 델리게이트들이다.
  </p>

  <hr />

  <h3>1-3. 직접 만든 델리게이트 vs Func / Action / Predicate</h3>

  <p>
    매번 <code>delegate ...</code>를 선언하기 귀찮으니까, .NET에서는 미리 여러 델리게이트 타입을 만들어두었다.
  </p>

  <ul>
    <li><code>Action</code>, <code>Action&lt;T&gt;</code>, <code>Action&lt;T1,T2,...&gt;</code> → 반환값 없음</li>
    <li><code>Func&lt;T1,...,TResult&gt;</code> → 마지막 타입이 반환형</li>
    <li><code>Predicate&lt;T&gt;</code> → 실질적으로 <code>Func&lt;T,bool&gt;</code>과 같은 역할</li>
  </ul>

  <p>예를 들어, 이런 전용 델리게이트를:</p>

  <pre><code class="language-csharp">delegate bool NumberTest(int n);</code></pre>

  <p>굳이 안 만들고 이렇게도 쓸 수 있다:</p>

  <pre><code class="language-csharp">Func&lt;int, bool&gt; test1 = n =&gt; n % 2 == 0;
Predicate&lt;int&gt; test2 = n =&gt; n &gt; 10;</code></pre>

  <p>
    요약하면:
  </p>

  <ul>
    <li>람다를 쓰려면 **어딘가에 담겨야 하는데**, 그 그릇이 델리게이트 타입이다.</li>
    <li>직접 선언한 전용 델리게이트: <code>delegate bool NumberTest(int n);</code></li>
    <li>미리 제공되는 전용 델리게이트: <code>Func</code>, <code>Action</code>, <code>Predicate&lt;T&gt;</code> 등</li>
    <li>람다 = 그 델리게이트에 들어가는 익명 메서드</li>
  </ul>

  <hr />

  <h2>2. 컬렉션과 람다 메서드 관점</h2>

  <p>
    두 번째 축은 <strong>컬렉션(List, 배열, LINQ)에서 람다를 어떻게 쓰는지</strong>이다.<br />
    실무에서는 이 부분에서 람다가 가장 많이 등장한다.
  </p>

  <h3>2-1. List&lt;T&gt; 메서드 + 람다</h3>

  <p><code>List&lt;T&gt;</code>에는 델리게이트를 받는 메서드가 아주 많다.</p>

  <ul>
    <li><code>Find(Predicate&lt;T&gt; match)</code></li>
    <li><code>FindAll(Predicate&lt;T&gt; match)</code></li>
    <li><code>Exists(Predicate&lt;T&gt; match)</code></li>
    <li><code>RemoveAll(Predicate&lt;T&gt; match)</code></li>
    <li><code>Sort(Comparison&lt;T&gt; comparison)</code></li>
    <li><code>ForEach(Action&lt;T&gt; action)</code></li>
  </ul>

  <p>모두 “델리게이트 인수”를 받기 때문에, 여기에 람다를 바로 넘겨줄 수 있다.</p>

  <h4>(1) Find / FindAll / Exists / RemoveAll 예제</h4>

  <pre><code class="language-csharp">var list = new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

// 1) Find: 조건을 만족하는 첫 번째 원소
int firstEven = list.Find(n =&gt; n % 2 == 0);

// 2) FindAll: 조건을 만족하는 모든 원소
List&lt;int&gt; evenList = list.FindAll(n =&gt; n % 2 == 0);

// 3) Exists: 조건을 만족하는 게 하나라도 있는지
bool hasBig = list.Exists(n =&gt; n &gt; 100);

// 4) RemoveAll: 조건을 만족하는 원소 모두 삭제
int removedCount = list.RemoveAll(n =&gt; n % 2 == 0);</code></pre>

  <ul>
    <li><code>n =&gt; n % 2 == 0</code> → <code>Predicate&lt;int&gt;</code> 타입에 맞는 람다식</li>
    <li>“이 숫자가 조건에 맞는지?”를 검사하는 작은 함수를 바로 인수로 넘긴 셈</li>
  </ul>

  <h4>(2) Sort + Comparison&lt;T&gt; 예제</h4>

  <pre><code class="language-csharp">var people = new List&lt;(string Name, int Age)&gt;
{
    ("Kim", 30),
    ("Lee", 20),
    ("Park", 40),
};

// 나이 기준 오름차순 정렬
people.Sort((a, b) =&gt; a.Age.CompareTo(b.Age));

// 이름 기준 내림차순 정렬
people.Sort((a, b) =&gt; string.Compare(b.Name, a.Name, StringComparison.Ordinal));</code></pre>

  <p>
    여기서 <code>(a, b) =&gt; ...</code> 부분이 바로 <code>Comparison&lt;T&gt;</code> 델리게이트에 전달되는 람다 메서드이다.
  </p>

  <hr />

  <h3>2-2. LINQ와 람다 – 컬렉션 처리의 핵심 조합</h3>

  <p>
    LINQ 확장 메서드들도 결국<br />
    <strong>“제네릭 메서드 + 델리게이트 인수 + 람다 전달”</strong> 구조이다.
  </p>

  <p>대표적인 메서드들:</p>

  <ul>
    <li><code>Where(Func&lt;T, bool&gt;)</code></li>
    <li><code>Select(Func&lt;TSource, TResult&gt;)</code></li>
    <li><code>Any(Func&lt;T, bool&gt;)</code></li>
    <li><code>All(Func&lt;T, bool&gt;)</code></li>
    <li><code>OrderBy(Func&lt;T, TKey&gt;)</code></li>
    <li><code>GroupBy(Func&lt;T, TKey&gt;)</code></li>
  </ul>

  <h4>(1) Where + Select + ToList 간단 예제</h4>

  <pre><code class="language-csharp">var numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5, 6 };

// 짝수만 고르고(Where), 제곱으로 바꾸고(Select), 리스트로 만들기(ToList)
var evenSquares = numbers
    .Where(n =&gt; n % 2 == 0)   // Func&lt;int, bool&gt;
    .Select(n =&gt; n * n)       // Func&lt;int, int&gt;
    .ToList();                // List&lt;int&gt;</code></pre>

  <ul>
    <li><code>Where</code> 안의 <code>n =&gt; n % 2 == 0</code> → <code>Func&lt;int,bool&gt;</code> 델리게이트에 들어가는 람다</li>
    <li><code>Select</code> 안의 <code>n =&gt; n * n</code> → <code>Func&lt;int,int&gt;</code> 델리게이트에 들어가는 람다</li>
  </ul>

  <h4>(2) 실무 스타일 예: 주문 목록 필터링</h4>

  <pre><code class="language-csharp">class Order
{
    public string CustomerCode { get; set; }
    public decimal Amount { get; set; }
    public bool IsCanceled { get; set; }
}

var orders = new List&lt;Order&gt;
{
    new Order { CustomerCode = "C001", Amount = 100_000m, IsCanceled = false },
    new Order { CustomerCode = "C001", Amount =  50_000m, IsCanceled = true  },
    new Order { CustomerCode = "C002", Amount = 200_000m, IsCanceled = false },
};

// 1) 취소되지 않은 주문만
var validOrders = orders
    .Where(o =&gt; !o.IsCanceled)
    .ToList();

// 2) 특정 거래처(C001) + 10만원 이상 주문만
var filtered = orders
    .Where(o =&gt; o.CustomerCode == "C001" &amp;&amp; o.Amount &gt;= 100_000m)
    .ToList();

// 3) 거래처별 매출 합계
var sumByCustomer = orders
    .Where(o =&gt; !o.IsCanceled)
    .GroupBy(o =&gt; o.CustomerCode)
    .Select(g =&gt; new
    {
        Customer = g.Key,
        Total = g.Sum(o =&gt; o.Amount)
    })
    .ToList();</code></pre>

  <p>
    여기 있는 모든 <code>=&gt;</code> 뒤의 코드들이 다 <strong>람다 메서드</strong>이고,<br />
    각각 <code>Func&lt;Order,bool&gt;</code>, <code>Func&lt;Order,string&gt;</code>, <code>Func&lt;Order,decimal&gt;</code> 등의 델리게이트 자리에 들어간다.
  </p>

  <hr />

  <h2>3. 두 관점을 한 번에 정리</h2>

  <h3>3-1. [람다 메서드를 위한 전용 델리게이트] 관점</h3>

  <ul>
    <li>람다식은 결국 <strong>델리게이트에 들어가는 익명 메서드</strong>다.</li>
    <li>델리게이트는 “이런 모양의 함수를 받을게”라고 선언하는 타입이다.
      <ul>
        <li>직접 만든 전용 델리게이트: <code>delegate bool NumberTest(int n);</code></li>
        <li>미리 제공된 델리게이트: <code>Func</code>, <code>Action</code>, <code>Predicate&lt;T&gt;</code>, <code>Comparison&lt;T&gt;</code> 등</li>
      </ul>
    </li>
    <li>
      공통 함수(<code>Count</code>, <code>Filter</code>, <code>Process</code> 등)에<br />
      “동작(조건/계산)을 나중에 결정하는 플러그인”으로 람다를 꽂는 느낌으로 쓰면 된다.
    </li>
  </ul>

  <h3>3-2. [컬렉션과 람다 메서드] 관점</h3>

  <ul>
    <li><code>List&lt;T&gt;</code>의 <code>Find</code>, <code>FindAll</code>, <code>Exists</code>, <code>Sort</code>, <code>RemoveAll</code>, <code>ForEach</code> 등은
      모두 델리게이트 인수를 받는다.</li>
    <li>여기에 람다를 넘겨서 “조건/정렬 기준/실행 동작”을 편하게 지정할 수 있다.</li>
    <li>LINQ의 <code>Where</code>, <code>Select</code>, <code>OrderBy</code>, <code>GroupBy</code> 등은
      <strong>제네릭 메서드 + Func 델리게이트 + 람다</strong>의 조합이다.</li>
    <li>실무에서 람다를 가장 많이 보는 곳은 결국
      <strong>“컬렉션 + 람다 = 데이터 필터링/변환/집계”</strong> 영역이다.</li>
  </ul>

  <p>
    이 두 관점을 머릿속에 같이 두면,
  </p>

  <blockquote>
    “람다 = 델리게이트에 들어가는 작은 메서드”<br />
    “컬렉션/ LINQ = 그 작은 메서드를 실전에서 쓰는 장소”
  </blockquote>

  <p>
    이렇게 연결돼서 훨씬 이해하기 쉬워진다.
  </p>
</article>