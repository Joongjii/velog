<article>

  <h2>1. <code>dynamic</code> 한 줄 정의</h2>

  <p>
    보통 <code>int</code>, <code>string</code> 같은 정적 타입들은:
  </p>
  <ul>
    <li><strong>컴파일 시점</strong>에 타입이 확정되고</li>
    <li>그 타입 기준으로 “이 멤버를 써도 되는지/안 되는지”를 컴파일러가 다 검사한다</li>
  </ul>

  <p>
    그런데 <code>dynamic</code>은 이렇게 행동한다:
  </p>

  <blockquote>
    “지금 컴파일할 땐 타입 검사하지 말고,<br />
    실행할 때 실제 타입을 보고 알아서 동작해봐.”
  </blockquote>

  <p>
    그래서:
  </p>

  <ul>
    <li>멤버 접근</li>
    <li>메서드 호출</li>
    <li>연산</li>
  </ul>

  <p>
    이런 것들이 전부 <strong>런타임에 결정</strong>된다.
  </p>

  <hr />

  <h2>2. 제일 중요한 특징: “컴파일러가 눈을 감는다”</h2>

  <pre><code class="language-csharp">dynamic x = 10;
x = "Hello";      // OK, 타입 바뀌어도 컴파일 에러 없음
x = DateTime.Now; // OK

Console.WriteLine(x.NonExistMethod()); // 컴파일은 통과하지만...</code></pre>

  <p>이 코드를 보면:</p>

  <ul>
    <li>컴파일할 때는 <strong>에러가 안 난다</strong><br />
      → 컴파일러가 “dynamic이면 일단 믿고 넘어갈게…” 모드라서
    </li>
    <li>실행 시점에 <code>x.NonExistMethod()</code>를 호출하려고 할 때,
      실제 <code>x</code> 타입에 그런 메서드가 없으면<br />
      <strong><code>RuntimeBinderException</code> 예외</strong>가 터진다
    </li>
  </ul>

  <p>
    반대로, 같은 걸 <code>object</code>로 쓰면:
  </p>

  <pre><code class="language-csharp">object x = 10;
x.NonExistMethod(); // ❌ 컴파일 에러 (object에는 그런 메서드 없음)</code></pre>

  <p>
    <code>object</code>일 때는 컴파일러가 타입을 알고 있으니까:
  </p>

  <blockquote>
    “야, <code>object</code>에는 <code>NonExistMethod</code> 같은 멤버 없어.”  
    → 컴파일 단계에서 바로 막아버린다.
  </blockquote>

  <p>
    정리하면:
  </p>

  <ul>
    <li><strong><code>object</code></strong> → 컴파일 시점에 타입이 <code>object</code>라서, <code>object</code> 범위 안에서만 사용 가능</li>
    <li><strong><code>dynamic</code></strong> → 컴파일러가 타입 체크를 포기하고, <strong>실행 시점에 실제 타입 기준으로</strong> 멤버를 찾고 호출을 시도</li>
  </ul>

  <hr />

  <h2>3. <code>dynamic</code> vs <code>var</code> – 제일 많이 헷갈리는 포인트</h2>

  <p>
    거의 100% 한 번씩 헷갈리는 부분이라, 확실히 정리해 두는 게 좋다.
  </p>

  <h3>3-1. <code>var</code></h3>

  <pre><code class="language-csharp">var s = "Hello";  // s는 컴파일 타임에 string으로 확정
s = 123;          // ❌ 컴파일 에러 (int 대입 불가)</code></pre>

  <ul>
    <li><code>var</code>는 그냥 <strong>“형식 추론”</strong>일 뿐이다.</li>
    <li>컴파일러가 <code>s</code>를 보고 “아, 이건 <code>string</code>이구나”라고 딱 정해버린다.</li>
    <li>이후에는 <code>string</code> 변수처럼 완전히 작동한다.</li>
  </ul>

  <h3>3-2. <code>dynamic</code></h3>

  <pre><code class="language-csharp">dynamic s = "Hello";  // s의 런타임 타입은 string, 컴파일러는 타입 검사 안 함
s = 123;              // OK, 이제 런타임 타입은 int로 바뀜</code></pre>

  <ul>
    <li><code>dynamic</code>은 타입이 <strong>런타임에 바뀔 수 있다</strong>.</li>
    <li>컴파일러가 타입 체크를 거의 안 한다.</li>
    <li>어떤 메서드를 호출하더라도 <strong>일단 컴파일은 통과</strong>하고,
      실행 중에 실제 타입에 맞는지 검사한다.</li>
  </ul>

  <h3>3-3. 표로 요약</h3>

  <table border="1" cellpadding="4" cellspacing="0">
    <thead>
      <tr>
        <th>키워드</th>
        <th>의미</th>
        <th>타입 결정 시점</th>
        <th>타입 체크</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>var</code></td>
        <td>형식 추론 (컴파일 시)</td>
        <td>컴파일 타임</td>
        <td>컴파일 타임에 엄격하게 검사</td>
      </tr>
      <tr>
        <td><code>dynamic</code></td>
        <td>런타임 바인딩 (동적 타입)</td>
        <td>런타임</td>
        <td>런타임에 검사</td>
      </tr>
    </tbody>
  </table>

  <hr />

  <h2>4. <code>dynamic</code>은 어디에 쓰는 게 좋을까?</h2>

  <p>
    대부분의 C# 코드는 <strong>정적 타입</strong>으로 깔끔하게 짜는 게 좋다.<br />
    그래도 <code>dynamic</code>이 유용한 상황이 분명 있다.
  </p>

  <h3>4-1. COM / Office 자동화 (Excel, Word 등)</h3>

  <p>기존 스타일:</p>

  <pre><code class="language-csharp">using Excel = Microsoft.Office.Interop.Excel;

Excel.Application app = new Excel.Application();
Excel.Workbook wb = app.Workbooks.Open("test.xlsx");
Excel.Worksheet ws = (Excel.Worksheet)wb.Sheets[1];</code></pre>

  <p>
    인터페이스/캐스팅이 많아서 코드가 좀 번거롭다.
  </p>

  <p><code>dynamic</code>을 쓰면:</p>

  <pre><code class="language-csharp">dynamic app = new Excel.Application();
dynamic wb = app.Workbooks.Open("test.xlsx");
dynamic ws = wb.Sheets[1];

ws.Cells[1, 1].Value = "Hello";</code></pre>

  <ul>
    <li>멤버를 전부 <code>dynamic</code>에 넣고 쓰면, 캐스팅/구체 타입을 덜 신경 써도 된다.</li>
    <li>대신, <strong>멤버 이름을 잘못 쓰면 런타임 에러</strong>가 난다.</li>
  </ul>

  <h3>4-2. 동적 언어(.NET 상의 Python, JS 등)와 연동</h3>

  <p>예를 들어 IronPython, ClearScript 같은 스크립트 엔진과 연동할 때:</p>

  <ul>
    <li>스크립트에서 넘어오는 객체의 타입을 C# 컴파일러가 미리 모른다.</li>
    <li><code>dynamic</code>으로 받아서 <strong>“그냥 메서드 있는 것처럼”</strong> 호출할 수 있다.</li>
  </ul>

  <pre><code class="language-csharp">dynamic pyObj = GetPythonObject(); // 예시
pyObj.Run();   // 런타임에 Run이 있는지 확인 후 호출</code></pre>

  <h3>4-3. JSON / <code>ExpandoObject</code>를 가볍게 다룰 때</h3>

  <p>예를 들어 Newtonsoft.Json을 사용할 때:</p>

  <pre><code class="language-csharp">dynamic obj = JsonConvert.DeserializeObject(json);
Console.WriteLine(obj.name);
Console.WriteLine(obj.address.city);</code></pre>

  <ul>
    <li>프로퍼티명을 문자열로 꺼내는 대신, 점(.)으로 바로 접근하는 코드를 작성할 수 있다.</li>
    <li>다만, 정석적으로는 DTO 클래스를 만들어서 <code>Person</code> 같은 타입으로 매핑하는 게 더 타입 안정성이 좋다.</li>
  </ul>

  <hr />

  <h2>5. 예제로 보는 <code>dynamic</code> 동작</h2>

  <h3>5-1. Duck Typing 비슷하게 사용하는 예</h3>

  <pre><code class="language-csharp">static void PrintLength(dynamic x)
{
    Console.WriteLine(x.Length);
}

PrintLength("Hello");            // string.Length → 5
PrintLength(new int[] {1,2,3});  // 배열.Length → 3
PrintLength(123);                // int에는 Length 없음 → 런타임 예외</code></pre>

  <p>
    컴파일러 입장:
  </p>

  <ul>
    <li>“<code>dynamic</code>이면 일단 <code>Length</code>가 있다고 믿자…” → 컴파일 OK</li>
    <li>실행 중에 실제 타입을 보고 <code>Length</code>를 찾는다.</li>
    <li>있으면 호출, 없으면 예외.</li>
  </ul>

  <hr />

  <h2>6. <code>dynamic</code>의 단점 / 주의할 점</h2>

  <h3>6-1. 타입 안전성이 떨어진다</h3>

  <pre><code class="language-csharp">dynamic x = "Hello";
int n = x;  // 컴파일 OK, 실행 시 예외 (string → int 변환 불가)</code></pre>

  <ul>
    <li><code>var</code>나 일반 정적 타입이라면 컴파일 단계에서 잡아줄 수 있는 오류도,</li>
    <li><code>dynamic</code>은 <strong>실행해 봐야만 알 수 있다</strong>.</li>
    <li>프로젝트가 커지고 팀원이 늘어나면, 이런 런타임 에러는 디버깅이 더 까다로워질 수 있다.</li>
  </ul>

  <h3>6-2. 성능 오버헤드</h3>

  <ul>
    <li>호출할 때마다 “어떤 멤버를 호출해야 할지”를 런타임에 찾아야 한다.</li>
    <li>즉, 내부적으로 항상 <strong>런타임 바인딩</strong> 작업이 수행된다.</li>
    <li>단순 정적 호출보다 느릴 수 있고, 특히 <strong>대량 루프 안에서 쓰면 부담</strong>이 될 수 있다.</li>
  </ul>

  <hr />

  <h2>7. 언제 쓰고, 언제 피해야 할까?</h2>

  <h3>써도 괜찮은/유리한 경우</h3>
  <ul>
    <li>COM / Office 자동화 코드 간단히 정리하고 싶을 때</li>
    <li>동적 언어(파이썬, JS 등)에서 넘어오는 객체를 편하게 다루고 싶을 때</li>
    <li>빠르게 프로토타입을 만들고, 나중에 정적 타입으로 정리할 생각일 때</li>
    <li>JSON을 잠깐 파싱해서 몇 개 필드만 임시로 보고 싶을 때</li>
  </ul>

  <h3>가능하면 피해야 하는 경우</h3>
  <ul>
    <li>핵심 도메인 로직, 중요한 계산 로직</li>
    <li>팀원이 많은 프로젝트의 공용 라이브러리/핵심 인프라 코드</li>
    <li>성능이 중요한 반복 루프 내부</li>
  </ul>

  <p>
    대부분의 일반적인 C# 개발에서는:
  </p>

  <ul>
    <li><strong>정적 타입 + 제네릭</strong>으로 설계하는 것이 기본 원칙이고,</li>
    <li><code>dynamic</code>은 진짜 필요한 구석(interop, 스크립팅, 테스트용)에서
     <br /> <strong>“도구 상자에서 잠깐 꺼내 쓰는 공구”</strong> 정도로 쓰는 게 좋다.</li>
  </ul>

  <hr />


</article>