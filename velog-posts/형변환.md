<article>

  <h2>1. 형변환이란?</h2>

  <blockquote>
    <strong>형변환(캐스팅) = 어떤 타입의 값을 다른 타입처럼 취급하는 것</strong>
  </blockquote>

  <p>예를 들면:</p>

  <pre><code class="language-csharp">int i = 10;
double d = i;      // int → double</code></pre>

  <p>
    이렇게 <code>int</code> 값을 <code>double</code> 변수에 넣는 것도 형변환이다.<br />
    C#에서는 크게 이런 종류들이 자주 나온다.
  </p>

  <ul>
    <li>묵시적 형변환 (implicit)</li>
    <li>명시적 형변환 (explicit, <code>(타입)</code> 캐스팅)</li>
    <li>참조 타입 캐스팅 (상속 관계, <code>is</code>, <code>as</code>)</li>
    <li>박싱/언박싱 (값 타입 ↔ object)</li>
  </ul>

  <hr />

  <h2>2. 묵시적 형변환 (Implicit Conversion)</h2>

  <p>
    <strong>컴파일러가 “이건 안전하다”라고 보고, 자동으로 해주는 형변환</strong>이다.<br />
    주로 <strong>“작은 타입 → 큰 타입”</strong>으로 갈 때 가능하다.
  </p>

  <h3>2-1. 숫자끼리 묵시적 형변환</h3>

  <pre><code class="language-csharp">int i = 10;
double d = i;   // OK, int → double 자동 변환</code></pre>

  <ul>
    <li><code>int</code>는 4바이트, <code>double</code>은 8바이트</li>
    <li><code>int</code> 값은 모두 <code>double</code>로 표현 가능</li>
    <li>데이터 손실 위험이 거의 없기 때문에 C#이 자동으로 허용</li>
  </ul>

  <p>다른 예:</p>

  <pre><code class="language-csharp">byte b = 100;
int i = b;      // OK, byte → int
long l = i;     // OK, int → long
float f = l;    // OK, long → float (근사값이 될 수 있지만 허용)</code></pre>

  <p>
    한 줄로 정리하면:
  </p>

  <blockquote>
    <strong>“작은 그릇 → 큰 그릇”으로 가는 건 대부분 자동 형변환이 된다.</strong>
  </blockquote>

  <hr />

  <h2>3. 명시적 형변환 (Explicit Casting)</h2>

  <p>
    이번에는 반대로, <strong>개발자가 직접 <code>(타입)</code>을 써줘야 하는 경우</strong>다.<br />
    주로 “큰 타입 → 작은 타입” 또는 <strong>데이터 손실 가능성이 있는 경우</strong>에 필요하다.
  </p>

  <h3>3-1. 숫자끼리 명시적 형변환 예제</h3>

  <pre><code class="language-csharp">double d = 3.14;
int i = (int)d;   // i는 3 (소수점 잘림)</code></pre>

  <ul>
    <li>소수점 이하 정보가 날아갈 수 있기 때문에</li>
    <li>C#은 자동 변환을 허용하지 않는다.</li>
    <li>개발자가 <code>(int)</code>를 써서 “내가 책임진다”고 표시해야 한다.</li>
  </ul>

  <p>또 다른 예:</p>

  <pre><code class="language-csharp">int big = 300;
byte b = (byte)big;  // 값이 잘릴 수 있음 (0~255 범위를 넘어서면 값이 뒤틀림)</code></pre>

  <p>
    이런 식으로 <strong>데이터가 잘리거나 값이 달라질 수 있는 변환</strong>은  
    반드시 <code>(타입)</code>으로 명시적 캐스팅이 필요하다.
  </p>

  <hr />

  <h2>4. 참조 타입 형변환 (상속, 업캐스팅/다운캐스팅)</h2>

  <p>
    숫자 타입만 형변환이 있는 게 아니다.  
    클래스/인터페이스 같은 <strong>참조 타입</strong>도 형변환이 있다.
  </p>

  <h3>4-1. 업캐스팅(Upcasting): 자식 → 부모 (안전, 묵시적)</h3>

  <pre><code class="language-csharp">class Animal
{
    public void Eat() =&gt; Console.WriteLine("먹는다");
}

class Dog : Animal
{
    public void Bark() =&gt; Console.WriteLine("멍멍");
}

class Program
{
    static void Main()
    {
        Dog d = new Dog();
        Animal a = d;   // 업캐스팅: Dog → Animal (묵시적 형변환 가능)

        a.Eat();        // OK
        // a.Bark();    // 컴파일 에러 (Animal 타입에는 Bark가 없음)
    }
}</code></pre>

  <ul>
    <li><code>Dog</code>는 <code>Animal</code>을 상속하므로, <code>Dog</code>는 곧 <code>Animal</code>이다.</li>
    <li>자식 → 부모로 가는 건 항상 안전하다.</li>
    <li>그래서 C#이 자동으로 형변환을 허용한다(묵시적).</li>
  </ul>

  <h3>4-2. 다운캐스팅(Downcasting): 부모 → 자식 (명시적, 위험할 수 있음)</h3>

  <pre><code class="language-csharp">Animal a = new Dog();   // 실제 인스턴스는 Dog
Dog d = (Dog)a;         // 다운캐스팅 (OK)

d.Bark();               // 사용 가능</code></pre>

  <p>하지만 이런 경우도 있다:</p>

  <pre><code class="language-csharp">Animal a = new Animal();
Dog d = (Dog)a;   // 컴파일은 되지만, 실행 시 InvalidCastException 발생</code></pre>

  <ul>
    <li><code>a</code>의 실제 인스턴스는 <code>Animal</code>일 뿐, <code>Dog</code>가 아니다.</li>
    <li>이 경우 다운캐스팅하면 런타임에서 예외가 터진다.</li>
  </ul>

  <p>
    그래서 C#에서는 안전하게 형 변환을 하기 위해 <strong><code>is</code></strong>와 <strong><code>as</code></strong>를 제공한다.
  </p>

  <hr />

  <h2>5. <code>is</code>, <code>as</code> 연산자</h2>

  <h3>5-1. <code>is</code> : “이 타입이 맞냐?” 검사</h3>

  <pre><code class="language-csharp">Animal a = new Dog();

if (a is Dog)
{
    Console.WriteLine("a는 Dog 타입이다");
}</code></pre>

  <p>C# 패턴 매칭을 쓰면 이렇게도 가능하다.</p>

  <pre><code class="language-csharp">if (a is Dog d)
{
    d.Bark(); // 여기서 d는 Dog 타입으로 캐스팅된 상태
}</code></pre>

  <h3>5-2. <code>as</code> : 캐스팅 시도, 안 되면 null</h3>

  <pre><code class="language-csharp">Animal a = new Dog();

Dog d = a as Dog;   // 캐스팅 성공 → d는 Dog
if (d != null)
{
    d.Bark();
}

Animal a2 = new Animal();
Dog d2 = a2 as Dog; // 캐스팅 실패 → d2는 null</code></pre>

  <ul>
    <li><code>as</code>는 예외를 던지지 않는다.</li>
    <li>캐스팅이 안 되면 그냥 <code>null</code>을 돌려준다.</li>
    <li>그래서 보통 <code>if (d != null)</code> 체크와 같이 사용한다.</li>
  </ul>

  <hr />

  <h2>6. 문자열 ↔ 숫자 변환 (Parse / TryParse)</h2>

  <p>
    이건 엄밀히 말하면 “캐스팅”보다는 <strong>파싱(Parsing)</strong>이지만,  
    실무에서는 형변환과 같이 다루는 경우가 많다.
  </p>

  <pre><code class="language-csharp">string s = "123";

// 문자열 → 숫자
int i1 = int.Parse(s);             // 실패 시 예외 발생

int i2;
bool ok = int.TryParse(s, out i2); // 실패해도 예외 없이 false 반환

// 숫자 → 문자열
int n = 456;
string s2 = n.ToString();</code></pre>

  <ul>
    <li>문자열 → 숫자: <code>Parse</code>, <code>TryParse</code></li>
    <li>숫자 → 문자열: <code>ToString()</code></li>
  </ul>

  <hr />

  <h2>7. 박싱(Boxing) / 언박싱(Unboxing)</h2>

  <p>
    C#에서는 모든 타입이 궁극적으로 <code>object</code>를 상속한다.<br />
    그래서 <code>int</code> 같은 값 타입도 <code>object</code>로 다룰 수 있는데,  
    이때 등장하는 개념이 <strong>박싱/언박싱</strong>이다.
  </p>

  <h3>7-1. 박싱(Boxing) – 값 타입 → object</h3>

  <pre><code class="language-csharp">int i = 10;
object o = i;   // 박싱 발생</code></pre>

  <p>
    값 타입 <code>i</code>가 힙에 <code>object</code> 형태로 포장되는 느낌으로 이해하면 편하다.
  </p>

  <h3>7-2. 언박싱(Unboxing) – object → 값 타입</h3>

  <pre><code class="language-csharp">object o = 10;     // int 박싱
int i = (int)o;    // 언박싱 (명시적 캐스팅 필요)</code></pre>

  <p>주의할 점:</p>

  <pre><code class="language-csharp">object o = 10;   // 실제로는 int

double d = (double)o;  // 런타임 오류 (InvalidCastException)</code></pre>

  <ul>
    <li><code>o</code> 안에 실제 들어있는 건 <code>int</code>인데,</li>
    <li><code>double</code>로 바로 캐스팅하려고 하면 예외가 발생한다.</li>
    <li>언박싱은 “원래 값 타입”으로만 가능하다.</li>
  </ul>

  <hr />

  <h2>8. 한 번에 정리</h2>

  <ul>
    <li>
      <strong>묵시적 형변환 (implicit)</strong>
      <ul>
        <li>컴파일러가 자동으로 해주는 형변환</li>
        <li>주로 작은 숫자 타입 → 큰 숫자 타입, 자식 → 부모(업캐스팅)</li>
        <li>예: <code>int i = 10; double d = i;</code></li>
      </ul>
    </li>
    <li>
      <strong>명시적 형변환 (explicit casting)</strong>
      <ul>
        <li><code>(타입)</code>을 써서 개발자가 직접 캐스팅</li>
        <li>데이터 손실 가능성이 있을 때 필요</li>
        <li>예: <code>double d = 3.14; int i = (int)d;</code></li>
      </ul>
    </li>
    <li>
      <strong>참조 타입 캐스팅</strong>
      <ul>
        <li>상속 관계에서의 형변환</li>
        <li>업캐스팅: 자식 → 부모 (자동, 안전)</li>
        <li>다운캐스팅: 부모 → 자식 (명시적, 잘못하면 런타임 예외)</li>
        <li><code>is</code>, <code>as</code>로 안전하게 검사/캐스팅 가능</li>
      </ul>
    </li>
    <li>
      <strong>문자열 ↔ 숫자 변환</strong>
      <ul>
        <li>문자열 → 숫자: <code>int.Parse</code>, <code>int.TryParse</code></li>
        <li>숫자 → 문자열: <code>ToString()</code></li>
      </ul>
    </li>
    <li>
      <strong>박싱 / 언박싱</strong>
      <ul>
        <li>값 타입 → object로 포장: 박싱</li>
        <li>object → 값 타입으로 꺼내기: 언박싱 (<code>(int)o</code> 같은 형변환 필요)</li>
        <li>언박싱은 원래 타입으로만 가능</li>
      </ul>
    </li>
  </ul>

</article>