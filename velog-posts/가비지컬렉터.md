<article>

  <hr />

  <h2>1. 가비지 컬렉터가 왜 필요할까?</h2>

  <p>
    C, C++ 같은 언어에서는 메모리를 직접 관리해야 한다.
  </p>

  <pre><code class="language-c">void* p = malloc(100);
// ...
free(p);
</code></pre>

  <ul>
    <li><code>free</code>를 깜빡하면 → 메모리 누수</li>
    <li>이미 해제한 메모리를 또 쓰면 → 크래시, 이상한 버그</li>
  </ul>

  <p>
    C#/.NET은 이런 귀찮고 위험한 일을 줄이기 위해 <strong>가비지 컬렉터(GC)</strong>를 도입했다.
  </p>

  <blockquote>
    <strong>GC = 더 이상 사용되지 않는 객체를 자동으로 찾아서 메모리를 회수해주는 시스템</strong>
  </blockquote>

  <p>
    개발자는 보통 <code>new</code>로 객체만 만들고,  
    “언제 free 할지”는 신경 안 써도 되게 만든 것.
  </p>

  <hr />

  <h2>2. 스택(stack) vs 힙(heap) 간단 복습</h2>

  <p>
    C# 메모리 구조를 아주 단순하게 나누면 이렇게 생각할 수 있다.
  </p>

  <h3>2-1. 스택(stack)</h3>

  <ul>
    <li>지역 변수, 매개변수 등이 주로 저장되는 영역</li>
    <li>메서드가 호출될 때 쌓이고, 리턴될 때 자동으로 제거된다 (LIFO 구조)</li>
  </ul>

  <pre><code class="language-csharp">void Foo()
{
    int x = 10;   // x는 스택에 위치
} // Foo가 끝나면 x도 자동으로 사라짐
</code></pre>

  <h3>2-2. 힙(heap)</h3>

  <ul>
    <li><code>new</code>로 생성되는 객체들이 저장되는 곳</li>
    <li><code>string</code>, <code>List&lt;T&gt;</code>, 사용자 정의 클래스 인스턴스 등</li>
  </ul>

  <pre><code class="language-csharp">void Foo()
{
    var list = new List&lt;int&gt;(); // List 객체는 힙에 생성
} // Foo가 끝나도 힙의 List는 자동으로 사라지지 않는다
</code></pre>

  <p>
    정리하면:
  </p>

  <ul>
    <li><strong>힙</strong> : 실제 객체가 있는 곳</li>
    <li><strong>스택</strong> : 그 객체를 가리키는 참조(주소)를 들고 있는 변수들이 있는 곳</li>
  </ul>

  <hr />

  <h2>3. 언제 객체가 “가비지(쓰레기)”가 될까?</h2>

  <p>
    GC가 객체를 지우려면 기준이 있어야 한다. 핵심은 딱 하나다:
  </p>

  <blockquote>
    <strong>“어디에서도 더 이상 참조하지 않는 객체” → 쓰레기</strong>
  </blockquote>

  <h3>3-1. 예시 1 – 메서드 안의 지역 변수</h3>

  <pre><code class="language-csharp">void Foo()
{
    var list = new List&lt;int&gt;();
    list.Add(1);
    list.Add(2);
} // 여기서 Foo 종료
</code></pre>

  <ul>
    <li><code>list</code>는 스택에 있는 지역 변수</li>
    <li>Foo가 끝나면 스택 프레임이 사라지고, <code>list</code>도 함께 사라진다</li>
    <li>이제 힙에 있는 <code>new List&lt;int&gt;()</code>를 가리키는 참조가 아무 것도 없다</li>
  </ul>

  <p>GC 입장에서는 이 객체는 이제 “어디에서도 도달 불가” → <strong>가비지</strong>가 된다.</p>

  <h3>3-2. 예시 2 – 여전히 참조가 남아 있는 경우</h3>

  <pre><code class="language-csharp">List&lt;int&gt; _cache;

void Make()
{
    _cache = new List&lt;int&gt;();
}

void Use()
{
    _cache.Add(1);
}
</code></pre>

  <ul>
    <li><code>_cache</code>는 필드(멤버 변수) → 프로그램이 살아 있는 동안 계속 유지될 수 있다</li>
    <li>따라서 <code>_cache</code>가 가리키는 List는 GC 대상이 아니다 (아직 “살아 있는 객체”)</li>
  </ul>

  <p>
    정리하면:
  </p>

  <blockquote>
    <strong>GC는 “참조가 끊어진 객체”만 지운다.</strong><br />
    참조가 남아 있으면, 아무리 우리가 “더 이상 안 쓰는데…”라고 생각해도 GC는 지우지 않는다.
  </blockquote>

  <hr />

  <h2>4. GC가 실제로 하는 일 (직관적 버전)</h2>

  <p>
    내부 구현은 엄청 복잡하지만, 개념적으로는 대략 이런 일을 한다고 보면 된다.
  </p>

  <ol>
    <li><strong>Root(루트) 찾기</strong><br />
      스택의 지역 변수들, static 필드들, CPU 레지스터 등  
      → 프로그램이 직접 들고 있는 참조들을 시작점으로 잡는다.
    </li>
    <li><strong>도달 가능한 객체 표시(mark)</strong><br />
      루트에서 참조를 따라가면서, 도달할 수 있는 모든 객체를 “살아 있음”으로 표시한다.
    </li>
    <li><strong>도달 불가능한 객체 찾기</strong><br />
      어떤 루트에서도 도달할 수 없는 객체들 = 더 이상 사용되지 않는 객체들 = 가비지.
    </li>
    <li><strong>가비지 제거 + 힙 정리(compact)</strong><br />
      가비지 객체들을 제거하고, 남은 객체들을 한쪽으로 몰아서 메모리를 연속적으로 만들기도 한다.
    </li>
  </ol>

  <p>
    이 과정에서 잠깐 <strong>GC가 도는 동안 해당 스레드가 멈추는 구간(stop-the-world)</strong>이 생길 수 있다.<br />
    성능 튜닝할 때는 이 <em>GC pause</em>도 고려해야 한다.
  </p>

  <hr />

  <h2>5. 세대별(Generation) GC – Gen 0 / Gen 1 / Gen 2</h2>

  <p>
    .NET GC는 성능을 높이기 위해 힙을 <strong>세대(Generation)</strong>로 나누어 관리한다.
  </p>

  <ul>
    <li><strong>Gen 0</strong> : 새로 생성된 객체들이 있는 영역 (아기)</li>
    <li><strong>Gen 1</strong> : 한 번 GC를 버틴 애들</li>
    <li><strong>Gen 2</strong> : 오래 살아남은 객체들 (노인)</li>
  </ul>

  <p>
    경험적으로 이런 특징이 있다.
  </p>

  <blockquote>
    “대부분의 객체는 금방 죽고,  
    생각보다 오래 사는 객체는 적다.”
  </blockquote>

  <p>
    따라서 GC는:
  </p>

  <ul>
    <li>Gen 0처럼 “금방 죽을 가능성이 큰 영역”을 위주로 자주 검사하고</li>
    <li>Gen 2처럼 오래 사는 영역은 덜 자주 검사한다</li>
  </ul>

  <p>
    지금 단계에서는:
  </p>

  <blockquote>
    <strong>“객체는 처음에 Gen 0에서 시작하고,  
    GC를 통과해 살아남으면 점점 위 세대로 승격된다”</strong>  
    이 정도만 알고 있어도 충분하다.
  </blockquote>

  <hr />

  <h2>6. GC는 언제 도는가?</h2>

  <p>
    우리가 <code>new</code>를 계속 호출해서 힙이 어느 정도 차면,  
    런타임이 “이제 한 번 청소할 때가 된 것 같은데?” 하고 GC를 돌린다.
  </p>

  <p>
    또한:
  </p>

  <ul>
    <li>메모리 상황을 보고 필요할 때</li>
    <li>CPU가 한가할 때 백그라운드로</li>
  </ul>

  <p>등 여러 요인을 고려해서 자동으로 실행된다.</p>

  <p>우리가 직접 호출할 수도 있다:</p>

  <pre><code class="language-csharp">GC.Collect();
</code></pre>

  <p>
    하지만 실무에서는 <strong>왠만하면 사용을 권장하지 않는다.</strong><br />
    런타임이 보통 우리보다 더 좋은 타이밍에 돌릴 수 있고,  
    우리가 억지로 자주 호출하면 오히려 성능이 떨어질 수 있기 때문이다.
  </p>

  <hr />

  <h2>7. GC가 “못 하는 일” – <code>IDisposable</code>, <code>using</code>과의 관계</h2>

  <p>
    GC는 어디까지나 <strong>“관리 힙 메모리”</strong>만 치운다.<br />
    그런데 객체 안에는 메모리 말고도 이런 것들이 들어있을 수 있다.
  </p>

  <ul>
    <li>파일 핸들</li>
    <li>데이터베이스 연결</li>
    <li>네트워크 소켓</li>
    <li>윈도우 핸들, GDI 리소스 등</li>
  </ul>

  <p>
    이런 것들은 OS 수준 자원이기 때문에, GC가 직접 정리해 줄 수 없다.<br />
    그래서 이런 타입들은 보통 <strong><code>IDisposable</code></strong>을 구현하고,  
    우리가 <code>Dispose()</code>를 호출해서 정리해야 한다.
  </p>

  <pre><code class="language-csharp">using (var fs = new FileStream("test.txt", FileMode.Open))
{
    // 파일 사용
} // 여기서 자동으로 fs.Dispose() 호출 → 파일 핸들 반납
</code></pre>

  <p>
    정리하면:
  </p>

  <ul>
    <li><strong>GC</strong> : 관리 힙 메모리 회수 담당</li>
    <li><strong><code>IDisposable</code> / <code>using</code></strong> : 파일 핸들, DB 연결 같은 <strong>비관리 자원</strong> 정리 담당</li>
  </ul>

  <hr />

  <h2>8. C#에서도 메모리 누수가 생길 수 있을까?</h2>

  <p>
    GC가 있는데도 왜 “메모리 누수” 얘기가 나올까?  
    이유는 아주 간단하다.
  </p>

  <blockquote>
    <strong>GC는 “참조가 있는 객체”는 절대로 지우지 않는다.</strong>
  </blockquote>

  <p>
    예를 들어:
  </p>

  <pre><code class="language-csharp">static List&lt;byte[]&gt; _cache = new List&lt;byte[]&gt;();

void Leak()
{
    var big = new byte[10 * 1024 * 1024]; // 10MB
    _cache.Add(big);                      // 전역 리스트에 계속 추가
}
</code></pre>

  <ul>
    <li><code>_cache</code>는 <code>static</code> 필드라 프로그램이 끝날 때까지 참조를 유지할 수 있다.</li>
    <li>여기에 10MB짜리 배열을 계속 넣으면, GC 입장에서는 “참조가 있으니 지우면 안 된다”고 판단한다.</li>
    <li>결과적으로 메모리는 계속 늘어나서 <strong>사실상 누수처럼 보이는 상황</strong>이 된다.</li>
  </ul>

  <p>
    즉, C#에서도:
  </p>

  <blockquote>
    <strong>우리가 참조를 계속 잡아두면, GC가 치울 수 없다.</strong><br />
    그래서 “참조를 언제 끊어줄지”도 중요한 설계 포인트다.
  </blockquote>

  <hr />



  <blockquote>
    <strong>GC는 “메모리 free를 자동으로 해주는 친구”지만,  
    우리가 참조를 어떻게 관리하느냐에 따라 효율과 안정성이 달라진다.</strong>
  </blockquote>

  <p>
    다음 단계로는:
  </p>

  <ul>
    <li>Finalizer(종료자) vs <code>IDisposable</code> 차이</li>
    <li>Large Object Heap(LOH)</li>
    <li>Server GC vs Workstation GC</li>
    <li>GC Pause(스톱 더 월드)와 성능 튜닝</li>
  </ul>

  <p>
    같은 내용을 공부하면, C#/.NET 메모리 관리에 대한 이해가 한층 더 깊어진다.
  </p>
</article>