<article>

  <hr />

  <h2>1. 형식 매개변수 제약조건이란?</h2>

  <p>
    기본적인 제네릭 클래스는 이렇게 생겼다:
  </p>

  <pre><code class="language-csharp">class MyClass&lt;T&gt;
{
    public T Value;
}</code></pre>

  <p>
    여기서 <code>T</code>에는 어떤 타입이든 들어갈 수 있다.
  </p>

  <pre><code class="language-csharp">var a = new MyClass&lt;int&gt;();
var b = new MyClass&lt;string&gt;();
var c = new MyClass&lt;DateTime&gt;();</code></pre>

  <p>
    그런데 가끔은 이런 식으로 제한하고 싶을 때가 있다:
  </p>

  <ul>
    <li>“T는 <strong>반드시 클래스 타입</strong>이어야 해”</li>
    <li>“T는 <strong>반드시 기본 생성자(new())</strong>가 있어야 해”</li>
    <li>“T는 <strong>내가 만든 BaseEntity를 상속한 타입</strong>만 허용하고 싶어”</li>
    <li>“T는 <strong>어떤 인터페이스를 구현한 타입</strong>만 받을래”</li>
  </ul>

  <p>
    이렇게 <strong>T에 조건을 거는 문법</strong>이 바로 제네릭 형식 매개변수에 대한 <strong>제약조건(Constraint)</strong>이다.
  </p>

  <p>
    문법 형태는 다음과 같다:
  </p>

  <pre><code class="language-csharp">class MyClass&lt;T&gt; where T : ...조건...</code></pre>

  <hr />

  <h2>2. 제약조건의 기본 종류</h2>

  <p>
    대표적으로 자주 쓰는 제약조건은 다음과 같다.
  </p>

  <ul>
    <li><code>where T : class</code> &rarr; T는 <strong>참조형</strong>(클래스)이어야 한다</li>
    <li><code>where T : struct</code> &rarr; T는 <strong>값 형식</strong>(struct)이어야 한다</li>
    <li><code>where T : new()</code> &rarr; T는 <strong>매개변수 없는 public 기본 생성자</strong>를 가져야 한다</li>
    <li><code>where T : SomeBaseClass</code> &rarr; T는 <strong>SomeBaseClass를 상속한 타입</strong>이어야 한다</li>
    <li><code>where T : ISomeInterface</code> &rarr; T는 <strong>ISomeInterface를 구현한 타입</strong>이어야 한다</li>
    <li><code>where T : unmanaged</code> &rarr; T는 <strong>비관리 값형</strong> (포인터로 다룰 수 있는 순수 값 타입)이어야 한다</li>
    <li><code>where T : notnull</code> &rarr; T는 <strong>null이 될 수 없는 타입</strong>이어야 한다 (nullable reference type과 연관)</li>
  </ul>

  <p>
    그리고 이 제약조건들은 <strong>콤마(,)</strong>로 이어서 여러 개를 동시에 걸 수도 있다.
  </p>

  <hr />

  <h2>3. <code>where T : class</code> – 참조형만 허용</h2>

  <pre><code class="language-csharp">class ReferenceOnlyBox&lt;T&gt; where T : class
{
    public T Value { get; set; }
}</code></pre>

  <pre><code class="language-csharp">var a = new ReferenceOnlyBox&lt;string&gt;();   // OK (string은 참조형)
var b = new ReferenceOnlyBox&lt;object&gt;();   // OK
// var c = new ReferenceOnlyBox&lt;int&gt;();   // ❌ 컴파일 에러 (int는 값 형식)</code></pre>

  <p>
    이런 경우에 쓴다:
  </p>

  <ul>
    <li>T가 항상 참조형이라고 가정하고 처리하고 싶을 때</li>
    <li>값 형식(int, double, struct 등)이 들어오는 걸 아예 막고 싶을 때</li>
  </ul>

  <hr />

  <h2>4. <code>where T : struct</code> – 값 형식만 허용</h2>

  <pre><code class="language-csharp">class ValueOnlyBox&lt;T&gt; where T : struct
{
    public T Value { get; set; }
}</code></pre>

  <pre><code class="language-csharp">var a = new ValueOnlyBox&lt;int&gt;();        // OK
var b = new ValueOnlyBox&lt;DateTime&gt;();   // OK

// var c = new ValueOnlyBox&lt;string&gt;();  // ❌ string은 참조형</code></pre>

  <p>
    이런 경우에 유용하다:
  </p>

  <ul>
    <li>T가 항상 값 형식이라서 <code>default(T)</code>가 null이 아니라고 가정할 수 있을 때</li>
    <li>nullable 처리, 포인터 연산, 성능 최적화 등을 값 형식 기준으로 설계할 때</li>
  </ul>

  <hr />

  <h2>5. <code>where T : new()</code> – 기본 생성자 필수</h2>

  <p>
    <strong>“제네릭 타입을 내가 직접 생성해야 하는 경우”</strong>에 자주 쓰는 제약조건이다.
  </p>

  <pre><code class="language-csharp">class Factory&lt;T&gt; where T : new()
{
    public T Create()
    {
        return new T(); // ★ new T()를 사용할 수 있게 됨
    }
}</code></pre>

  <pre><code class="language-csharp">class User
{
    public string Name { get; set; }

    public User()   // 매개변수 없는 기본 생성자
    {
    }
}

var factory = new Factory&lt;User&gt;();
User u = factory.Create(); // OK</code></pre>

  <p>
    만약 <code>User</code>가 매개변수 있는 생성자만 있고 기본 생성자가 없다면,
    <code>where T : new()</code> 제약을 만족하지 못해서 컴파일 에러가 난다.
  </p>

  <p>
    이런 곳에 잘 어울린다:
  </p>

  <ul>
    <li>리포지토리가 엔티티 인스턴스를 직접 만들어야 할 때</li>
    <li>공통 Factory / Builder / DTO 생성기 같은 걸 만들 때</li>
  </ul>

  <hr />

  <h2>6. <code>where T : SomeBaseClass</code> – 특정 베이스 클래스 상속</h2>

  <pre><code class="language-csharp">class EntityBase
{
    public int Id { get; set; }
}

class Repository&lt;T&gt; where T : EntityBase
{
    public void Save(T entity)
    {
        Console.WriteLine($"Id: {entity.Id} 저장");
    }
}</code></pre>

  <pre><code class="language-csharp">class User : EntityBase
{
    public string Name { get; set; }
}

class Product : EntityBase
{
    public string ItemName { get; set; }
}

var userRepo = new Repository&lt;User&gt;();      // OK
var productRepo = new Repository&lt;Product&gt;(); // OK

// class Something { }
// var repo = new Repository&lt;Something&gt;();  // ❌ EntityBase 상속 안 했으므로 에러</code></pre>

  <p>
    포인트는 이거다:
  </p>

  <blockquote>
    <strong>Repository&lt;T&gt; 내부에서는 T가 최소한 EntityBase의 멤버(Id 등)를 가지고 있다는 게 보장된다.</strong>
  </blockquote>

  <p>
    그래서 <code>entity.Id</code>, <code>entity.CreatedAt</code> 같은 공통 속성을  
    제네릭 타입에도 안전하게 사용할 수 있다.
  </p>

  <hr />

  <h2>7. <code>where T : 인터페이스</code> – 특정 인터페이스 구현</h2>

  <pre><code class="language-csharp">interface IHasName
{
    string Name { get; set; }
}

class NamePrinter&lt;T&gt; where T : IHasName
{
    public void Print(T obj)
    {
        Console.WriteLine(obj.Name);  // ★ 인터페이스의 Name 사용 가능
    }
}</code></pre>

  <pre><code class="language-csharp">class User : IHasName
{
    public string Name { get; set; }
}

class Company : IHasName
{
    public string Name { get; set; }
}

var p1 = new NamePrinter&lt;User&gt;();
p1.Print(new User { Name = "홍길동" });

var p2 = new NamePrinter&lt;Company&gt;();
p2.Print(new Company { Name = "ABC Corp" });</code></pre>

  <p>
    이 패턴의 장점:
  </p>

  <ul>
    <li>구체 타입(User, Company 등)에 의존하지 않고,</li>
    <li><strong>“이 인터페이스만 구현하면 다 받을 수 있다”</strong>는 식으로 설계가 가능하다.</li>
  </ul>

  <p>
    실무에서 가장 자주 쓰는 제약조건 패턴 중 하나다.
  </p>

  <hr />

  <h2>8. 여러 제약조건을 한 번에 걸기</h2>

  <p>
    제약조건은 콤마로 이어서 여러 개를 동시에 걸 수 있다.
  </p>

  <pre><code class="language-csharp">class MyService&lt;T&gt;
    where T : EntityBase, IHasName, new()
{
    public T CreateDefault()
    {
        var obj = new T();        // new() 제약 덕분에 생성 가능
        obj.Name = "기본 이름";   // IHasName 제약 덕분에 Name 사용 가능
        return obj;
    }
}</code></pre>

  <p>
    여기서 T는 다음 조건을 모두 만족해야 한다:
  </p>

  <ol>
    <li><code>EntityBase</code>를 상속해야 하고</li>
    <li><code>IHasName</code> 인터페이스를 구현해야 하고</li>
    <li><code>public</code> 기본 생성자를 가지고 있어야 한다</li>
  </ol>

  <p>
    <strong>제약조건 순서 규칙도 중요하다:</strong>
  </p>

  <ul>
    <li>클래스/struct/구체적인 베이스클래스 &rarr; 제일 앞</li>
    <li>인터페이스들 &rarr; 그 다음</li>
    <li><code>new()</code> &rarr; 항상 맨 마지막</li>
  </ul>

  <p>
    예를 들어:
  </p>

  <pre><code class="language-csharp">where T : EntityBase, IHasName, new()  // ✅ 올바른 순서
// where T : new(), EntityBase, IHasName  // ❌ 잘못된 순서, 컴파일 에러</code></pre>

  <hr />

  <h2>9. 제네릭 메서드에도 제약조건을 걸 수 있다</h2>

  <p>
    클래스 전체가 제네릭이 아니어도, <strong>메서드 하나만 제네릭</strong>이고 거기에 제약조건을 걸 수 있다.
  </p>

  <pre><code class="language-csharp">class Util
{
    public static T CreateAndLog&lt;T&gt;() where T : new()
    {
        T obj = new T();
        Console.WriteLine(typeof(T).Name + " 생성됨");
        return obj;
    }
}</code></pre>

  <pre><code class="language-csharp">class User
{
    public User() { }
}

var user = Util.CreateAndLog&lt;User&gt;();  // User는 기본 생성자가 있어야 함</code></pre>

  <p>
    이런 식으로 재사용 가능한 유틸리티 메서드를 깔끔하게 만들 수 있다.
  </p>

  <hr />

  <h2>10. 한 번에 정리</h2>

  <p>
    C# 제네릭 형식 매개변수 제약조건은 한 줄로 요약하면:
  </p>

  <blockquote>
    <strong>“제네릭 타입/메서드에서 T에 들어올 수 있는 타입을 제한해서,  
    안쪽 코드가 ‘T가 최소한 이 정도 기능은 가진 타입이다’라고 믿고 쓸 수 있게 해주는 장치”</strong>
  </blockquote>

  <p>자주 쓰는 패턴만 다시 모으면:</p>

  <pre><code class="language-csharp">// 1) 참조형만
where T : class

// 2) 값 형식만
where T : struct

// 3) 어떤 베이스 클래스 상속
where T : BaseClass

// 4) 어떤 인터페이스 구현
where T : ISomeInterface

// 5) 기본 생성자 필요
where T : new()

// 6) 여러 개 한꺼번에
where T : BaseClass, ISomeInterface, new()</code></pre>

  <p>
    실무에서는 보통 이런 상황에서 자주 보게 된다:
  </p>

  <ul>
    <li>공통 <code>Repository&lt;T&gt;</code> 만들 때 → <code>where T : EntityBase, new()</code></li>
    <li>이름/ID 등 공통 속성이 있는 타입만 처리하는 유틸 → <code>where T : IHasName</code></li>
    <li>값 형식 전용 유틸, 참조형 전용 유틸 만들 때 → <code>class</code>, <code>struct</code> 제약</li>
  </ul>

  <p>
    제약조건까지 이해하면 제네릭을 단순히 “타입 하나 받는 문법”이 아니라,  
    <strong>“타입에 대한 규칙을 걸 수 있는 강력한 설계 도구”</strong>로 볼 수 있게 된다.
  </p>
</article>